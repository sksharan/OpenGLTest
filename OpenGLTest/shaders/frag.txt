#version 330

/* Represents a point light. */
struct PointLight {
	/* Position of this light (in world coordinates). */
    vec4 position;
	/* Ambient component */
	vec3 La;
	/* Diffuse component */
	vec3 Ld;
	/* Specular component */
	vec3 Ls;
	/* Light intensity */
	float intensity;
};

/* Represents a directional light. */
struct DirectionalLight {
	/* Direction of this light */
    vec4 direction;
	/* Ambient component */
	vec3 La;
	/* Diffuse component */
	vec3 Ld;
	/* Specular component */
	vec3 Ls;
	/* Light intensity */
	float intensity;
};

/* Arrays of lights. */
uniform PointLight pLights[4];         //corresponds to MAX_POINT_LIGHTS in Constants.h
uniform DirectionalLight dLights[2];   //corresponds to MAX_DIRECTIONAL_LIGHTS in Constants.h

/* Number of lights currently in use. */
uniform int numPLights;               //should not exceed length of pLights
uniform int numDLights;               //should not exceed length of dLights

/* Sampler for the object's base texture. */
uniform sampler2D texture0;

/* Transformation matrices. */
uniform mat4 perspectiveMatrix;
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

/* Input values. */
in vec4 f_eye_position;
in vec2 f_texcoord;
in vec3 f_eye_normal;

/* Output values. */
out vec4 frag_color;

/* Test for point light. See http://antongerdelan.net/opengl/phong.html
for more details. */
vec3 pointLightTestWithPhong() {
    //Light constants
	vec4 light_pos_world = vec4(0, 0, 10, 1);
    vec4 light_pos_eye = viewMatrix * light_pos_world;
	vec3 La = vec3(0.2, 0.2, 0.2);
	vec3 Ld = vec3(0.7, 0.7, 0.7);
    vec3 Ls = vec3(1.0, 1.0, 1.0);

	//Object constants
	vec3 Ka = vec3(1.0, 1.0, 1.0);
	vec3 Kd = vec3(1.0, 0.5, 0.0);
	vec3 Ks = vec3(1.0, 1.0, 1.0);
	float shininess = 40.0;

	//ambient term
	vec3 Ia = La * Ka;

	//diffuse term
	vec3 direction_to_light_eye = normalize( vec3(light_pos_eye - f_eye_position) );
	vec3 Id = Ld * Kd * max( dot(direction_to_light_eye, f_eye_normal), 0.0 );

	//specular term
	vec3 reflection_eye = reflect(-direction_to_light_eye, f_eye_normal);
	vec3 direction_to_viewer_eye = normalize( -vec3(f_eye_position) );  //can do this since we're working in eye space
	float specular_dot_prod = max( dot(reflection_eye, direction_to_viewer_eye), 0.0 );
	vec3 Is = Ls * Ks * pow(specular_dot_prod, shininess);

	return Ia + Id + Is;
}

/* Test the value of the normals. Right-facing parts are red, upward-facing
parts are green, and forward-facing parts are blue. Any negative values are
clamped to 0. See http://antongerdelan.net/opengl/debugshaders.html for more details. */
vec4 testNormals() {
    return vec4(f_eye_normal, 1.0); 
}

void main() {
    //frag_color = testNormals();
	//frag_color = texture(texture0, f_texcoord);
	frag_color = vec4(pointLightTestWithPhong(), 1.0);
}